import subprocess

def download_video():
    """
    Handles the logic for downloading video content.
    Asks for single/playlist, best/normal quality, link, and whether to embed English subtitles.
    Uses yt-dlp and ffmpeg to download and embed only English subs into MKV if requested.
    """
    # 1. Single or playlist?
    single_or_playlist = input("Do you want to download a single video or a playlist? (single/playlist): ").strip().lower()
    
    # 2. Best or normal quality?
    best_or_normal = input("Choose quality: (best/normal): ").strip().lower()
    
    # 3. Paste the link
    link = input("Please paste your link here: ").strip()
    
    # 4. Subtitles needed or not?
    subtitles_needed = input("Do you want to embed English subtitles? (y/n): ").strip().lower()
    
    # Build the base command for yt-dlp
    command = ["yt-dlp"]
    
    # Decide the format based on the userâ€™s desired quality
    if best_or_normal == "best":
        # bestvideo+bestaudio fallback to best
        command += ["-f", "bv*+ba/b"]
    else:
        # a more "normal" fallback 
        command += ["-f", "bv*+ba/b", "--limit-rate", "1M"]  # example: limit to ~1Mbps
    
    # If subtitles are needed, we instruct yt-dlp to:
    #  - download only English subtitles
    #  - download auto-generated if normal subs are not available
    #  - embed them into the final file
    #  - convert them to SRT format before embedding
    if subtitles_needed == "y":
        command += [
            "--write-subs",            # download subtitles if available
            "--write-auto-subs",       # download autogenerated subs if normal subs not available
            "--sub-langs", "en",       # only English subtitles
            "--embed-subs",            # embed the downloaded subtitles
            "--convert-subs", "srt",   # convert to srt before embedding
        ]
    
    # We want the final container to be MKV (which supports embedded subs well)
    command += ["--merge-output-format", "mkv"]
    
    # If the user specifically indicated 'playlist', we can force yt-dlp to treat the URL as a playlist
    if single_or_playlist == "playlist":
        command += ["--yes-playlist"]
    else:
        command += ["--no-playlist"]
    
    # Add the link as the final part of the command
    command.append(link)
    
    # Print command for debugging (optional):
    print("Executing command:", " ".join(command))
    
    # Run the command
    subprocess.run(command, check=True)


def download_audio():
    """
    Handles the logic for downloading audio content.
    Asks for single/playlist and best/normal quality, then extracts audio.
    No subtitles are handled for audio downloads.
    """
    # 1. Single or playlist?
    single_or_playlist = input("Do you want to download a single track or a playlist? (single/playlist): ").strip().lower()
    
    # 2. Best or normal quality?
    best_or_normal = input("Choose audio quality: (best/normal): ").strip().lower()
    
    # 3. Paste the link
    link = input("Please paste your link here: ").strip()
    
    # Build the command
    command = ["yt-dlp"]
    
    # Choose the audio format based on best/normal
    if best_or_normal == "best":
        command += ["-f", "bestaudio"]
    else:
        # There's no official "normal" audio, so we might limit the bitrate or fallback
        command += ["-f", "bestaudio", "--limit-rate", "512K"]  # example limit
    
    # Extract audio, choose your preferred audio format
    command += [
        "--extract-audio",         
        "--audio-format", "mp3"    # can change to "m4a", "opus", "wav", etc.
    ]
    
    # Handle single or playlist
    if single_or_playlist == "playlist":
        command += ["--yes-playlist"]
    else:
        command += ["--no-playlist"]
    
    # Finally add the link
    command.append(link)
    
    # Print command for debugging (optional)
    print("Executing command:", " ".join(command))
    
    # Run the command
    subprocess.run(command, check=True)


def main():
    """
    Main function to run the YouTube downloader script. 
    Asks user whether they want to download video or audio,
    then calls the corresponding function.
    """
    print("Welcome to the YouTube Downloader using yt-dlp and ffmpeg!")
    print("Please ensure you have installed Python, FFmpeg, and yt-dlp before proceeding.\n")
    
    choice = input("What would you like to download? (video/audio): ").strip().lower()
    
    if choice == "video":
        download_video()
    elif choice == "audio":
        download_audio()
    else:
        print("Invalid choice. Exiting.")


if __name__ == "__main__":
    main()
